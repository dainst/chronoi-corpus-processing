diff --git a/src/de/unihd/dbs/uima/annotator/heideltime/HeidelTime.java b/src/de/unihd/dbs/uima/annotator/heideltime/HeidelTime.java
index e94f96b..e7e3c27 100644
--- a/src/de/unihd/dbs/uima/annotator/heideltime/HeidelTime.java
+++ b/src/de/unihd/dbs/uima/annotator/heideltime/HeidelTime.java
@@ -167,6 +167,8 @@ public class HeidelTime extends JCasAnnotator_ImplBase {
 		/////////////////////////////////////////////////////////////////////////////////
 		procMan.registerProcessor("de.unihd.dbs.uima.annotator.heideltime.processors.HolidayProcessor");
 		procMan.registerProcessor("de.unihd.dbs.uima.annotator.heideltime.processors.DecadeProcessor");
+		procMan.registerProcessor("de.unihd.dbs.uima.annotator.heideltime.processors.LiteratureExtractionProcessor$PreDisambiguationProcessor", Priority.PRE_DISAMBIGUATION);
+		procMan.registerProcessor("de.unihd.dbs.uima.annotator.heideltime.processors.LiteratureExtractionProcessor$PostDisambiguationProcessor", Priority.POST_DISAMBIGUATION);
 		procMan.initializeAllProcessors(aContext);
 		
 		/////////////////////////////
@@ -284,11 +286,17 @@ public class HeidelTime extends JCasAnnotator_ImplBase {
 		if (deleteOverlapped == true)
 			deleteOverlappedTimexesPreprocessing(jcas);
 
+		// modules may inject functionality before the disambiguation step
+		procMan.executeProcessors(jcas, Priority.PRE_DISAMBIGUATION);
+
 		/*
 		 * specify ambiguous values, e.g.: specific year for date values of
 		 * format UNDEF-year-01-01; specific month for values of format UNDEF-last-month
 		 */
 		specifyAmbiguousValues(jcas);
+
+		// modules may inject functionality after the disambiguation step
+		procMan.executeProcessors(jcas, Priority.POST_DISAMBIGUATION);
 		
 		// disambiguate historic dates
 		// check dates without explicit hints to AD or BC if they might refer to BC dates
diff --git a/src/de/unihd/dbs/uima/annotator/heideltime/ProcessorManager.java b/src/de/unihd/dbs/uima/annotator/heideltime/ProcessorManager.java
index 11f06d7..17f67c0 100644
--- a/src/de/unihd/dbs/uima/annotator/heideltime/ProcessorManager.java
+++ b/src/de/unihd/dbs/uima/annotator/heideltime/ProcessorManager.java
@@ -108,6 +108,6 @@ public class ProcessorManager {
 	}
 	
 	public enum Priority {
-		PREPROCESSING, POSTPROCESSING, ARBITRARY
+		PREPROCESSING, POSTPROCESSING, ARBITRARY, PRE_DISAMBIGUATION, POST_DISAMBIGUATION
 	}
 }
diff --git a/src/de/unihd/dbs/uima/annotator/heideltime/processors/LiteratureExtractionProcessor.java b/src/de/unihd/dbs/uima/annotator/heideltime/processors/LiteratureExtractionProcessor.java
new file mode 100644
index 0000000..977327c
--- /dev/null
+++ b/src/de/unihd/dbs/uima/annotator/heideltime/processors/LiteratureExtractionProcessor.java
@@ -0,0 +1,113 @@
+package de.unihd.dbs.uima.annotator.heideltime.processors;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.regex.MatchResult;
+import java.util.regex.Pattern;
+
+import org.apache.uima.UimaContext;
+import org.apache.uima.cas.FSIterator;
+import org.apache.uima.jcas.JCas;
+
+import de.unihd.dbs.uima.annotator.heideltime.utilities.Logger;
+import de.unihd.dbs.uima.annotator.heideltime.utilities.Toolbox;
+import de.unihd.dbs.uima.types.heideltime.Sentence;
+import de.unihd.dbs.uima.types.heideltime.Timex3;
+
+public class LiteratureExtractionProcessor {
+
+	public static class PreDisambiguationProcessor extends GenericProcessor {
+
+		@Override
+		public void initialize(UimaContext aContext) throws ProcessorInitializationException {
+			return;
+		}
+
+		@Override
+		public void process(JCas jcas) throws ProcessorProcessingException {
+			extractLitRefTimexes(jcas);
+		}
+	}
+
+	public static class PostDisambiguationProcessor extends GenericProcessor {
+
+		@Override
+		public void initialize(UimaContext aContext) throws ProcessorInitializationException {
+			return;
+		}
+
+		@Override
+		public void process(JCas jcas) throws ProcessorProcessingException {
+			reIntegrateLitRefTimexes(jcas);
+		}
+	}
+
+	private static final ConcurrentHashMap<JCas, List<Timex3>> EXTRACTED_TIMEXES = new ConcurrentHashMap<JCas, List<Timex3>>();
+
+	private static final Pattern PARENS = Pattern.compile("\\([^\\)]*\\)");
+
+	private static void reIntegrateLitRefTimexes(JCas jcas) throws ProcessorProcessingException {
+		List<Timex3> timexes = EXTRACTED_TIMEXES.get(jcas);
+		if (timexes != null) {
+			for (Timex3 timex : timexes) {
+				timex.addToIndexes(jcas);
+			}
+			EXTRACTED_TIMEXES.remove(jcas);
+		}
+	}
+
+	private static void extractLitRefTimexes(JCas jcas) throws ProcessorProcessingException {
+		// collect all timexes that are inside of literature references
+		List<Timex3> toIgnore = new LinkedList<Timex3>();
+		FSIterator iterTimex = jcas.getAnnotationIndex(Timex3.type).iterator();
+		while (iterTimex.hasNext()) {
+			Timex3 timex = (Timex3) iterTimex.next();
+			Sentence sentence = getCoveringSentence(jcas, timex);
+
+			if (isTimexWithinLiteratureReference(timex, sentence)) {
+				toIgnore.add(timex);
+			}
+		}
+
+		// remove these timexes from further consideration
+		for (Timex3 timex : toIgnore) {
+			timex.removeFromIndexes(jcas);
+		}
+		// save the ignored timexes so they may be re-added later
+		EXTRACTED_TIMEXES.put(jcas, toIgnore);
+	}
+
+	private static Sentence getCoveringSentence(JCas jcas, Timex3 timex) throws ProcessorProcessingException {
+		FSIterator iterSentences = jcas.getAnnotationIndex(Sentence.type).iterator();
+		while (iterSentences.hasNext()) {
+			Sentence sentence = (Sentence) iterSentences.next();
+			if (timex.getBegin() >= sentence.getBegin() && timex.getEnd() <= sentence.getEnd()) {
+				return sentence;
+			}
+		}
+		Logger.printError("No covering sentence found for timex: " + timex.getCoveredText());
+		throw new ProcessorProcessingException();
+	}
+
+	private static boolean isTimexWithinLiteratureReference(Timex3 timex, Sentence sentence) {
+		boolean result = false;
+
+		int localStart = timex.getBegin() - sentence.getBegin();
+		int localEnd = timex.getEnd() - sentence.getBegin();
+		for (MatchResult mr : Toolbox.findMatches(PARENS, sentence.getCoveredText())) {
+			// check that the match covers the local timex
+			if (mr.start() < localStart && mr.end() > localEnd) {
+				result = true;
+
+				String parenExpr = sentence.getCoveredText().substring(mr.start(), mr.end());
+				System.err.println("Keeping back temporarily: " + parenExpr);
+
+				break;
+			}
+		}
+
+		return result;
+	}
+
+}
